import { Event } from "./event";
import { AttributeParser } from "./attributes";
import { Options, Warning } from "./options";
type Opener = {
    matchIndex: number;
    startpos: number;
    endpos: number;
    annot: null | string;
    subMatchIndex: number;
    substartpos: null | number;
    subendpos: null | number;
};
type OpenerMap = {
    [opener: string]: Opener[];
};
declare class InlineParser {
    options: Options;
    warn: (warning: Warning) => void;
    subject: string;
    matches: Event[];
    openers: OpenerMap;
    verbatim: number;
    verbatimType: string;
    destination: boolean;
    firstpos: number;
    lastpos: number;
    allowAttributes: boolean;
    attributeParser: null | AttributeParser;
    attributeStart: null | number;
    attributeSlices: null | {
        startpos: number;
        endpos: number;
    }[];
    matchers: Record<number, (self: InlineParser, sp: number, ep: number) => null | number>;
    constructor(subject: string, options?: Options);
    addMatch(startpos: number, endpos: number, annot: string, matchIndex?: number): void;
    inVerbatim(): boolean;
    singleChar(pos: number): number;
    reparseAttributes(): void;
    getMatches(): Event[];
    addOpener(name: string, startpos: number, endpos: number, defaultAnnot: string): void;
    clearOpeners(startpos: number, endpos: number): void;
    strMatches(startpos: number, endpos: number): void;
    feed(startpos: number, endpos: number): void;
}
export { InlineParser };
