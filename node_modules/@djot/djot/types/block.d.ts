import { Event } from "./event";
import { Options, Warning } from "./options";
import { AttributeParser } from "./attributes";
import { InlineParser } from "./inline";
type EventIterator = {
    next: () => {
        value: Event;
        done: boolean;
    };
};
declare enum ContentType {
    None = 0,
    Inline = 1,
    Block = 2,
    Text = 3,
    Cells = 4,
    Attributes = 5,
    ListItem = 6
}
type BlockSpec = {
    name: string;
    type: ContentType;
    content: ContentType;
    continue: (container: Container) => boolean;
    open: (spec: BlockSpec) => boolean;
    close: () => void;
};
declare class Container {
    name: string;
    type: ContentType;
    content: ContentType;
    continue: (container: Container) => boolean;
    close: () => void;
    indent: number;
    inlineParser: InlineParser | null;
    attributeParser: AttributeParser | null;
    extra: {
        [key: string]: any;
    };
    constructor(spec: BlockSpec, extra: {
        [key: string]: any;
    });
}
declare class EventParser {
    options: Options;
    warn: (warning: Warning) => void;
    subject: string;
    maxoffset: number;
    indent: number;
    startline: number;
    starteol: number;
    endeol: number;
    matches: Event[];
    containers: Container[];
    pos: number;
    lastMatchedContainer: number;
    finishedLine: boolean;
    returned: number;
    specs: BlockSpec[];
    paraSpec: BlockSpec;
    constructor(subject: string, options?: Options);
    find(patt: RegExp): null | {
        startpos: number;
        endpos: number;
        captures: string[];
    };
    tip(): Container | null;
    addMatch(startpos: number, endpos: number, annot: string): void;
    getInlineMatches(): void;
    closeUnmatchedContainers(): void;
    addContainer(container: Container, skipCloseUnmatched?: boolean): Container;
    skipSpace(): void;
    getEol(): void;
    parseTableCell(): null | {
        startpos: number;
        endpos: number;
        matches: Event[];
    };
    parseTableRow(sp: number, ep: number): boolean;
    [Symbol.iterator](): EventIterator;
}
declare const parseEvents: (input: string, options?: Options) => EventParser;
export { parseEvents };
