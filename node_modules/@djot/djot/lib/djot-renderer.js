"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.renderDjot = void 0;
const ast_1 = require("./ast");
const parse_1 = require("./parse");
const isWhitespace = function (node) {
    const tag = node.tag;
    return (tag === "space" || tag === "soft_break" || tag === "hard_break");
};
const beginsWithWhitespace = function (node) {
    return (node.children[0] && isWhitespace(node.children[0]));
};
const endsWithWhitespace = function (node) {
    return (node.children[0] &&
        isWhitespace(node.children[node.children.length - 1]));
};
const verbatimDelim = function (node, minticks) {
    const backtickGroups = node.text.match(/(`+)/g);
    const backtickGroupLens = {};
    if (backtickGroups) {
        for (const i in backtickGroups) {
            backtickGroupLens[backtickGroups[i].length] = true;
        }
    }
    let numticks = minticks;
    while (backtickGroupLens[numticks]) {
        numticks++;
    }
    return "`".repeat(numticks);
};
const toRoman = function (x) {
    if (x < 0 || x >= 4000) {
        return "?";
    }
    let rom = "";
    while (x > 0) {
        if (x >= 1000) {
            rom += "M";
            x -= 1000;
        }
        else if (x >= 900) {
            rom += "CM";
            x -= 900;
        }
        else if (x >= 500) {
            rom += "D";
            x -= 500;
        }
        else if (x >= 400) {
            rom += "CD";
            x -= 400;
        }
        else if (x >= 100) {
            rom += "C";
            x -= 100;
        }
        else if (x >= 90) {
            rom += "XC";
            x -= 90;
        }
        else if (x >= 50) {
            rom += "L";
            x -= 50;
        }
        else if (x >= 40) {
            rom += "XL";
            x -= 40;
        }
        else if (x >= 10) {
            rom += "X";
            x -= 10;
        }
        else if (x == 9) {
            rom += "IX";
            x -= 9;
        }
        else if (x >= 5) {
            rom += "V";
            x -= 5;
        }
        else if (x == 4) {
            rom += "IV";
            x -= 4;
        }
        else if (x >= 1) {
            rom += "I";
            x -= 1;
        }
        else {
            throw (new Error("toRoman encountered x = " + x));
        }
    }
    return rom;
};
const formatNumber = function (num, style) {
    const delimPattern = style.replace(/[a-zA-Z0-9]+/g, "$");
    const numFormat = style.replace(/[.()]/g, "");
    let numStr;
    switch (numFormat) {
        case "1":
            numStr = num.toString();
            break;
        case "a":
            numStr = String.fromCodePoint(96 + (num % 26));
            break;
        case "A":
            numStr = String.fromCodePoint(64 + (num % 26));
            break;
        case "i":
            numStr = toRoman(num).toLowerCase();
            break;
        case "I":
            numStr = toRoman(num);
            break;
        default:
            throw (new Error("formatNumber encountered unknown style " + style));
    }
    return delimPattern.replace("$", numStr);
};
class DjotRenderer {
    constructor(doc, options = {}) {
        this.prefixes = [];
        this.buffer = [];
        this.startOfLine = true;
        this.endOfPrefix = 0;
        this.column = 0;
        this.needsBlankLine = false;
        this.handlers = {
            doc: (node) => {
                this.renderChildren(node.children);
                this.prefixes = [];
                this.cr();
                const hasReferences = Object.keys(node.references).length > 0;
                if (hasReferences) {
                    this.cr();
                    this.newline();
                }
                for (const k in node.references) {
                    this.renderNode(node.references[k]);
                }
                const hasFootnotes = Object.keys(node.footnotes).length > 0;
                for (const k in node.footnotes) {
                    this.renderNode(node.footnotes[k]);
                }
                this.prefixes = [];
                this.cr();
            },
            footnote: (node) => {
                this.lit("[^" + node.label + "]:");
                this.space();
                this.needsBlankLine = false;
                this.prefixes.push("  ");
                this.renderChildren(node.children);
                this.prefixes.pop();
                this.blankline();
            },
            reference: (node) => {
                this.lit("[");
                this.lit(node.label);
                this.lit("]:");
                this.prefixes.push("  ");
                this.space();
                this.lit(node.destination);
                this.wrap();
                this.prefixes.pop();
                this.blankline();
            },
            para: (node) => {
                this.renderChildren(node.children);
                this.blankline();
            },
            thematic_break: () => {
                this.lit("* * * * *");
                this.blankline();
            },
            div: (node) => {
                this.lit(":::");
                this.cr();
                this.renderChildren(node.children);
                this.cr();
                this.lit(":::");
                this.blankline();
            },
            heading: (node) => {
                const hashes = "#".repeat(node.level);
                this.lit(hashes + " ");
                this.prefixes.push(hashes + " ");
                this.renderChildren(node.children);
                this.prefixes.pop();
                this.blankline();
            },
            block_quote: (node) => {
                this.prefixes.push("> ");
                this.lit("> ");
                this.renderChildren(node.children);
                this.prefixes.pop();
                this.blankline();
            },
            section: (node) => {
                this.renderChildren(node.children);
            },
            code_block: (node) => {
                const ticks = verbatimDelim(node, 3);
                this.lit(ticks);
                if (node.lang) {
                    this.lit(" " + node.lang);
                }
                this.cr();
                this.litlines(node.text);
                this.cr();
                this.lit(ticks);
                this.blankline();
            },
            raw_block: (node) => {
                const ticks = verbatimDelim(node, 3);
                this.lit(ticks);
                this.lit(" =" + node.format);
                this.cr();
                this.litlines(node.text);
                this.cr();
                this.lit(ticks);
                this.blankline();
            },
            definition_list: (node) => {
                const items = node.children;
                for (let i = 0; i < items.length; i++) {
                    const item = items[i];
                    if (i > 0) {
                        this.newline();
                    }
                    this.lit(":");
                    this.needsBlankLine = false;
                    this.space();
                    this.prefixes.push(" ".repeat(2));
                    this.renderChildren(item.children);
                    this.prefixes.pop();
                }
            },
            ordered_list: (node) => {
                const style = node.style;
                const start = node.start || 1;
                const items = node.children;
                const tight = node.tight;
                for (let i = 0; i < items.length; i++) {
                    const item = items[i];
                    if (i > 0) {
                        this.cr();
                        if (!tight) {
                            this.newline();
                        }
                    }
                    const marker = formatNumber(start + i, style);
                    this.lit(marker);
                    this.needsBlankLine = false;
                    this.space();
                    this.prefixes.push(" ".repeat(marker.length + 1));
                    this.renderChildren(item.children);
                    this.prefixes.pop();
                }
                if (tight) { // otherwise we already have a blankline
                    this.blankline();
                }
            },
            bullet_list: (node) => {
                const items = node.children;
                const tight = node.tight;
                for (let i = 0; i < items.length; i++) {
                    const item = items[i];
                    if (i > 0) {
                        this.cr();
                        if (!tight) {
                            this.newline();
                        }
                    }
                    const marker = node.style;
                    this.lit(marker);
                    this.needsBlankLine = false;
                    this.space();
                    this.prefixes.push(" ".repeat(marker.length + 1));
                    this.renderChildren(item.children);
                    this.prefixes.pop();
                }
                if (tight) { // otherwise we already have a blankline
                    this.blankline();
                }
            },
            task_list: (node) => {
                const items = node.children;
                const tight = node.tight;
                for (let i = 0; i < items.length; i++) {
                    const item = items[i];
                    if (i > 0) {
                        this.cr();
                        if (!tight) {
                            this.newline();
                        }
                    }
                    this.needsBlankLine = false;
                    this.lit(`- [${item.checkbox === "checked" ? "X" : " "}]`);
                    this.space();
                    this.prefixes.push(" ".repeat(6));
                    this.renderChildren(item.children);
                    this.prefixes.pop();
                }
                if (tight) { // otherwise we already have a blankline
                    this.blankline();
                }
            },
            term: (node) => {
                this.renderChildren(node.children);
                this.blankline();
            },
            definition: (node) => {
                this.renderChildren(node.children);
            },
            table: (node) => {
                const captions = node.children.filter(ast_1.isCaption);
                const rows = node.children.filter(ast_1.isRow);
                for (let i = 0; i < rows.length; i++) {
                    const row = rows[i];
                    // if last row was head and this is not, add separator line
                    if ("head" in row && !row.head && i > 0 &&
                        rows[i - 1].head) {
                        const lastRow = rows[i - 1];
                        for (let j = 0; j < lastRow.children.length; j++) {
                            if (j === 0) {
                                this.lit("|");
                            }
                            switch (lastRow && lastRow.children[j].align) {
                                case "left":
                                    this.lit(":--");
                                    break;
                                case "right":
                                    this.lit("--:");
                                    break;
                                case "center":
                                    this.lit(":-:");
                                    break;
                                default:
                                    this.lit("---");
                            }
                            this.lit("|");
                        }
                        this.cr();
                    }
                    // now add the proper row
                    for (let j = 0; j < row.children.length; j++) {
                        const cell = row.children[j];
                        if (j === 0) {
                            this.lit("|");
                        }
                        this.noWrap(() => {
                            // this awkward test is needed because a Caption can
                            // be a child of Table; revisit this?
                            if (cell.tag === "cell") {
                                this.renderChildren(cell.children);
                            }
                        });
                        this.lit("|");
                    }
                    this.cr();
                }
                if (captions.length > 0 && captions[0].children.length > 0) {
                    this.newline();
                    this.lit("^ ");
                    this.needsBlankLine = false;
                    this.prefixes.push("  ");
                    this.renderChildren(captions[0].children);
                    this.prefixes.pop();
                    this.blankline();
                }
                this.blankline();
            },
            str: (node) => {
                node.text.split(/  */).forEach((s, i) => {
                    if (i > 0) {
                        this.space();
                    }
                    this.out(s);
                });
            },
            space: () => { this.space(); },
            soft_break: () => { this.soft_break(); },
            smart_punctuation: (node) => { this.lit(node.text); },
            non_breaking_space: () => { this.lit("\\ "); },
            single_quoted: this.inlineContainer("'"),
            double_quoted: this.inlineContainer("\""),
            emph: this.inlineContainer("_"),
            strong: this.inlineContainer("*"),
            superscript: this.inlineContainer("^"),
            subscript: this.inlineContainer("~"),
            mark: this.inlineContainer("=", true),
            delete: this.inlineContainer("-", true),
            insert: this.inlineContainer("+", true),
            footnote_reference: (node) => {
                this.lit("[^" + node.text + "]");
            },
            symb: (node) => {
                this.lit(":" + node.alias + ":");
            },
            email: (node) => {
                this.lit("<" + node.text + ">");
            },
            url: (node) => {
                this.lit("<" + node.text + ">");
            },
            span: (node) => {
                this.lit("[");
                this.renderChildren(node.children);
                this.lit("]");
            },
            link: (node) => {
                this.lit("[");
                this.renderChildren(node.children);
                this.lit("]");
                if (node.reference) {
                    this.lit("[");
                    if (node.reference !== (0, parse_1.getStringContent)(node)) {
                        this.lit(node.reference);
                    }
                    this.lit("]");
                }
                else if (node.destination) {
                    this.lit("(");
                    this.lit(node.destination);
                    this.lit(")");
                }
                else { // should not happen
                    this.lit("()");
                }
            },
            image: (node) => {
                this.lit("![");
                this.renderChildren(node.children);
                this.lit("]");
                if (node.reference) {
                    this.lit("[");
                    if (node.reference !== (0, parse_1.getStringContent)(node)) {
                        this.lit(node.reference);
                    }
                    this.lit("]");
                }
                else if (node.destination) {
                    this.lit("(");
                    this.lit(node.destination);
                    this.lit(")");
                }
                else { // should not happen
                    this.lit("()");
                }
            },
            raw_inline: (node) => {
                this.verbatimNode(node);
                this.lit("{=" + node.format + "}");
            },
            verbatim: (node) => {
                this.verbatimNode(node);
            },
            inline_math: (node) => {
                this.lit("$");
                this.verbatimNode(node);
            },
            display_math: (node) => {
                this.lit("$$");
                this.verbatimNode(node);
            }
        };
        this.doc = doc;
        this.wrapWidth = (options === null || options === void 0 ? void 0 : options.wrapWidth) || 0;
    }
    escape(s) {
        s = s.replace(/([~`'"${}[\]^<>\\*_]|-(?=-)|!(=\[)|\.(?=\.))/g, "\\$1");
        if (this.column === 0 || this.column === this.endOfPrefix) {
            s = s.replace(/^#/, "\\#");
        }
        return s;
    }
    out(s) {
        this.lit(this.escape(s));
    }
    doBlankLines() {
        if (this.needsBlankLine) {
            this.cr();
            this.newline();
            this.needsBlankLine = false;
        }
    }
    lit(s) {
        this.buffer.push(s);
        this.column += s.length;
        this.startOfLine = false;
    }
    blankline() {
        this.needsBlankLine = true;
    }
    newline() {
        if (this.endOfPrefix === this.column) {
            // remove spaces after prefix
            while (/  *$|^$/.test(this.buffer[this.buffer.length - 1])) {
                this.buffer[this.buffer.length - 1] =
                    this.buffer[this.buffer.length - 1].replace(/  *$/, "");
                if (this.buffer[this.buffer.length - 1] === "") {
                    this.buffer.pop();
                }
            }
        }
        this.endOfPrefix = 0;
        this.column = 0;
        this.buffer.push("\n");
        if (this.prefixes.length > 0) {
            for (let i = 0, len = this.prefixes.length; i < len; i++) {
                this.buffer.push(this.prefixes[i]);
                this.column += this.prefixes[i].length;
            }
            this.endOfPrefix = this.column;
        }
        this.startOfLine = true;
    }
    cr() {
        if (!this.startOfLine) {
            this.newline();
        }
    }
    wrap() {
        if (this.wrapWidth <= 0) {
            return;
        }
        let idx = this.buffer.length - 1;
        if (!this.startOfLine && this.buffer.length > 0 &&
            this.column > this.wrapWidth) {
            // backup to last space:
            let lastbuff;
            while (idx >= 0) {
                lastbuff = this.buffer[idx];
                if (lastbuff === " ") {
                    break;
                }
                else if (/^[ \r\n]+$/.test(lastbuff)) { // e.g. indentation
                    return; // can't wrap
                }
                idx--;
            }
        }
        if (idx < this.buffer.length - 1) {
            const excessOnLine = this.buffer.splice(idx + 1);
            if (this.buffer[this.buffer.length - 1] === " ") {
                this.buffer.pop(); // pop space at end of line
            }
            // put the content on next line:
            this.newline();
            this.startOfLine = true;
            for (let i = 0; i < excessOnLine.length; i++) {
                this.buffer.push(excessOnLine[i]);
                this.column += excessOnLine[i].length;
                this.startOfLine = false;
            }
        }
    }
    space() {
        this.wrap();
        this.lit(" ");
    }
    soft_break() {
        if (this.wrapWidth === 0) {
            this.newline();
        }
        else {
            this.space();
        }
    }
    needsBraces(node) {
        return (beginsWithWhitespace(node) ||
            endsWithWhitespace(node) ||
            (this.buffer.length > 0 &&
                /\w$/.test(this.buffer[this.buffer.length - 1])));
    }
    noWrap(action) {
        const oldWrapWidth = this.wrapWidth;
        this.wrapWidth = -1; // no wrap + soft breaks are spaces
        action();
        this.wrapWidth = oldWrapWidth;
    }
    inlineContainer(delim, needsBraces) {
        const self = this;
        return function (node) {
            needsBraces = needsBraces || self.needsBraces(node);
            if (needsBraces)
                self.lit("{");
            self.lit(delim);
            self.renderChildren(node.children);
            self.lit(delim);
            if (needsBraces)
                self.lit("}");
        };
    }
    litlines(s) {
        const lns = s.split(/\r?\n/);
        if (lns[lns.length - 1] === "") {
            lns.pop();
        }
        for (const ln of lns) {
            this.lit(ln);
            this.cr();
        }
    }
    verbatimNode(node) {
        const ticks = verbatimDelim(node, 1);
        this.lit(ticks);
        if (/^`/.test(node.text)) {
            this.lit(" ");
        }
        this.lit(node.text);
        if (/`$/.test(node.text)) {
            this.lit(" ");
        }
        this.lit(ticks);
    }
    renderChildren(children) {
        for (let i = 0, len = children.length; i < len; i++) {
            this.renderNode(children[i]);
        }
        if (children[0] && !(0, ast_1.isBlock)(children[0])) {
            this.wrap();
        }
    }
    renderNode(node) {
        this.doBlankLines();
        const handler = this.handlers[node.tag];
        if (handler) {
            if (node.attributes && (0, ast_1.isBlock)(node)) {
                this.renderAttributes(node);
                this.cr();
            }
            handler(node);
            if (node.attributes && (0, ast_1.isInline)(node)) {
                this.renderAttributes(node);
            }
        }
        else {
            throw (new Error("No renderer defined for node type " + node.tag));
        }
    }
    renderAttributes(node) {
        if (!node.attributes || Object.keys(node.attributes).length === 0) {
            return;
        }
        const attr = node.attributes;
        this.lit("{");
        let isfirst = true;
        if ((0, ast_1.isBlock)(node)) {
            this.prefixes.push(" ");
        }
        for (const k in attr) {
            if (!isfirst) {
                this.space();
            }
            if (k === "id") {
                this.lit("#");
                this.lit(attr[k]);
            }
            else if (k === "class") {
                const classes = attr[k].split(/  */);
                for (let i = 0; i < classes.length; i++) {
                    if (i > 0) {
                        this.space();
                    }
                    this.lit(".");
                    this.lit(classes[i]);
                }
            }
            else {
                this.lit(k);
                this.lit("=\"");
                this.out(attr[k]);
                this.lit("\"");
            }
            isfirst = false;
        }
        if ((0, ast_1.isBlock)(node)) {
            this.prefixes.pop();
        }
        this.lit("}");
    }
    render() {
        this.renderNode(this.doc);
        return this.buffer.join("");
    }
}
const renderDjot = function (doc, options = {}) {
    return new DjotRenderer(doc, options).render();
};
exports.renderDjot = renderDjot;
