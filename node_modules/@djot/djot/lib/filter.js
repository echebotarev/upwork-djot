"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.applyFilter = void 0;
class Walker {
    constructor(node) {
        this.finished = false;
        this.stack = [];
        this.enter = true;
        this.top = node;
        this.current = node;
    }
    walk(callback) {
        while (!this.finished) {
            callback(this); // apply the action to current this state
            const topStack = this.stack && this.stack[this.stack.length - 1];
            if (this.enter) {
                if ("children" in this.current &&
                    this.current.children.length > 0) {
                    // move to first child
                    this.stack.push({ node: this.current, childIndex: 0 });
                    this.current = this.current.children[0];
                    this.enter = true;
                }
                else {
                    // no children, set to exit
                    this.enter = false;
                }
            }
            else { // exit
                if (topStack) {
                    // try next sibling
                    topStack.childIndex++;
                    const nextChild = topStack.node.children[topStack.childIndex];
                    if (nextChild) {
                        this.current = nextChild;
                        this.enter = true;
                    }
                    else {
                        this.stack.pop();
                        // go up to parent
                        this.current = topStack.node;
                        this.enter = false;
                    }
                }
                else {
                    this.finished = true;
                }
            }
        }
    }
}
const applyFilterPartToNode = function (node, enter, filterpart) {
    if (!node || !node.tag) {
        throw (new Error("Filter called on a non-node."));
    }
    const trans = filterpart[node.tag];
    if (!trans) {
        return false;
    }
    let transform;
    if (enter) {
        if ("enter" in trans && trans.enter) {
            transform = trans.enter;
        }
    }
    else {
        if ("exit" in trans && trans.exit) {
            transform = trans.exit;
        }
        else {
            transform = trans;
        }
    }
    if (typeof transform === "function") {
        return transform(node);
    }
};
// Returns the node for convenience (but modifies it in place).
const traverse = function (node, filterpart) {
    new Walker(node).walk((walker) => {
        let result = applyFilterPartToNode(walker.current, walker.enter, filterpart);
        const stackTop = walker.stack[walker.stack.length - 1];
        if (typeof result === "object" && "stop" in result && result.stop) {
            result = result.stop;
            walker.enter = false; // set to exit, which stops traversal of children
        }
        if (result) {
            if (Array.isArray(result)) {
                if (stackTop) {
                    stackTop.node.children.splice(stackTop.childIndex, 1, ...result);
                    // next line is needed for cases where we delete an element
                    walker.current = stackTop.node.children[stackTop.childIndex];
                    // adjust childIndex to skip multiple items added;
                    if (result.length > 1) {
                        stackTop.childIndex += result.length - 1;
                    }
                }
                else {
                    throw (Error("Cannot replace top node with multiple nodes"));
                }
            }
            else if (typeof result === "object" && "tag" in result && result.tag) {
                if (stackTop) {
                    stackTop.node.children[stackTop.childIndex] = result;
                }
                else {
                    return result;
                }
            }
        }
    });
    return node;
};
// Apply a filter to a document.
const applyFilter = function (doc, filter) {
    const f = filter();
    let filterparts;
    if (Array.isArray(f)) {
        filterparts = f;
    }
    else {
        filterparts = [f];
    }
    for (const f of filterparts) {
        traverse(doc, f);
        for (const i in doc.footnotes) {
            traverse(doc.footnotes[i], f);
        }
        for (const i in doc.references) {
            traverse(doc.references[i], f);
        }
    }
};
exports.applyFilter = applyFilter;
