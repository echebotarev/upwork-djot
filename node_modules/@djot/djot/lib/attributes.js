"use strict";
/* Parser for attributes, implemented as a state machine.
 *
 * attributes { id = "foo", class = "bar baz",
 *              key1 = "val1", key2 = "val2" }
 * syntax:
 *
 * attributes <- '{' whitespace* attribute (whitespace attribute)* whitespace* '}'
 * attribute <- identifier | class | keyval
 * identifier <- '#' name
 * class <- '.' name
 * name <- (nonspace, nonpunctuation other than ':', '_', '-')+
 * keyval <- key '=' val
 * key <- (ASCII_ALPHANUM | ':' | '_' | '-')+
 * val <- bareval | quotedval
 * bareval <- (ASCII_ALPHANUM | ':' | '_' | '-')+
 * quotedval <- '"' ([^"] | '\"') '"'
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.AttributeParser = void 0;
// states
var State;
(function (State) {
    State[State["SCANNING"] = 0] = "SCANNING";
    State[State["SCANNING_ID"] = 1] = "SCANNING_ID";
    State[State["SCANNING_CLASS"] = 2] = "SCANNING_CLASS";
    State[State["SCANNING_KEY"] = 3] = "SCANNING_KEY";
    State[State["SCANNING_VALUE"] = 4] = "SCANNING_VALUE";
    State[State["SCANNING_BARE_VALUE"] = 5] = "SCANNING_BARE_VALUE";
    State[State["SCANNING_QUOTED_VALUE"] = 6] = "SCANNING_QUOTED_VALUE";
    State[State["SCANNING_QUOTED_VALUE_CONTINUATION"] = 7] = "SCANNING_QUOTED_VALUE_CONTINUATION";
    State[State["SCANNING_ESCAPED"] = 8] = "SCANNING_ESCAPED";
    State[State["SCANNING_ESCAPED_IN_CONTINUATION"] = 9] = "SCANNING_ESCAPED_IN_CONTINUATION";
    State[State["SCANNING_COMMENT"] = 10] = "SCANNING_COMMENT";
    State[State["FAIL"] = 11] = "FAIL";
    State[State["DONE"] = 12] = "DONE";
    State[State["START"] = 13] = "START";
})(State || (State = {}));
const reKeyChar = /^[a-zA-Z0-9_:-]/;
const isKeyChar = function (c) {
    return reKeyChar.exec(c) !== null;
};
const handlers = [];
handlers[State.START] = function (parser, pos) {
    if (parser.subject.charAt(pos) === '{') {
        return State.SCANNING;
    }
    else {
        return State.FAIL;
    }
};
handlers[State.FAIL] = function (parser, pos) {
    return State.FAIL;
};
handlers[State.DONE] = function (parser, pos) {
    return State.DONE;
};
handlers[State.SCANNING] = function (parser, pos) {
    const c = parser.subject.charAt(pos);
    if (c === '\n' || c === '\r') {
        return State.SCANNING;
    }
    else if (c === ' ' || c === '\t') {
        parser.addEvent(pos, pos, "attr_space");
        return State.SCANNING;
    }
    else if (c === '}') {
        return State.DONE;
    }
    else if (c === '#') {
        parser.begin = pos;
        parser.addEvent(pos, pos, "attr_id_marker");
        return State.SCANNING_ID;
    }
    else if (c === '%') {
        parser.begin = pos;
        return State.SCANNING_COMMENT;
    }
    else if (c === '.') {
        parser.begin = pos;
        parser.addEvent(pos, pos, "attr_class_marker");
        return State.SCANNING_CLASS;
    }
    else if (isKeyChar(c)) {
        parser.begin = pos;
        return State.SCANNING_KEY;
    }
    else {
        return State.FAIL;
    }
};
handlers[State.SCANNING_COMMENT] = function (parser, pos) {
    const c = parser.subject.charAt(pos);
    if (c === '%') {
        if (parser.begin && pos > parser.begin) {
            parser.addEvent(parser.begin, pos, "comment");
        }
        return State.SCANNING;
    }
    else if (c == '}') {
        return State.DONE;
    }
    else {
        return State.SCANNING_COMMENT;
    }
};
handlers[State.SCANNING_ID] = function (parser, pos) {
    const c = parser.subject.charAt(pos);
    if ((/^[^\]\[~!@#$%^&*(){}`,.<>\\|=+/?\s]/.exec(c) !== null)) {
        return State.SCANNING_ID;
    }
    else if (c === '}') {
        if (parser.begin && parser.lastpos && parser.lastpos > parser.begin) {
            parser.addEvent(parser.begin + 1, parser.lastpos, "id");
        }
        parser.begin = null;
        return State.DONE;
    }
    else if (/^\s/.exec(c) !== null) {
        if (parser.begin && parser.lastpos && parser.lastpos > parser.begin) {
            parser.addEvent(parser.begin + 1, parser.lastpos, "id");
        }
        if (!(c === '\r' || c === '\n')) {
            parser.addEvent(pos, pos, "attr_space");
        }
        parser.begin = null;
        return State.SCANNING;
    }
    else {
        return State.FAIL;
    }
};
handlers[State.SCANNING_CLASS] = function (parser, pos) {
    const c = parser.subject.charAt(pos);
    if ((/^\w/.exec(c) !== null) || c === '_' || c === '-' || c === ':') {
        return State.SCANNING_CLASS;
    }
    else if (c === '}') {
        if (parser.begin && parser.lastpos && parser.lastpos > parser.begin) {
            parser.addEvent(parser.begin + 1, parser.lastpos, "class");
        }
        parser.begin = null;
        return State.DONE;
    }
    else if (/^\s/.exec(c) !== null) {
        if (parser.begin && parser.lastpos && parser.lastpos > parser.begin) {
            parser.addEvent(parser.begin + 1, parser.lastpos, "class");
        }
        if (!(c === '\r' || c === '\n')) {
            parser.addEvent(pos, pos, "attr_space");
        }
        parser.begin = null;
        return State.SCANNING;
    }
    else {
        return State.FAIL;
    }
};
handlers[State.SCANNING_KEY] = function (parser, pos) {
    const c = parser.subject.charAt(pos);
    if (c === '=' && parser.begin && parser.lastpos) {
        parser.addEvent(parser.begin, parser.lastpos, "key");
        parser.addEvent(pos, pos, "attr_equal_marker");
        parser.begin = null;
        return State.SCANNING_VALUE;
    }
    else if (/^[a-zA-Z0-9_:-]/.exec(c) !== null) {
        return State.SCANNING_KEY;
    }
    else {
        return State.FAIL;
    }
};
handlers[State.SCANNING_VALUE] = function (parser, pos) {
    const c = parser.subject.charAt(pos);
    if (c === '"') {
        parser.begin = pos;
        parser.addEvent(pos, pos, "attr_quote_marker");
        return State.SCANNING_QUOTED_VALUE;
    }
    else if (/^[a-zA-Z0-9_:-]/.exec(c) !== null) {
        parser.begin = pos;
        return State.SCANNING_BARE_VALUE;
    }
    else {
        return State.FAIL;
    }
};
handlers[State.SCANNING_BARE_VALUE] = function (parser, pos) {
    const c = parser.subject.charAt(pos);
    if (/^[a-zA-Z0-9_:-]/.exec(c) !== null) {
        return State.SCANNING_BARE_VALUE;
    }
    else if (c === '}' && parser.begin && parser.lastpos) {
        parser.addEvent(parser.begin, parser.lastpos, "value");
        parser.begin = null;
        return State.DONE;
    }
    else if (/^\s/.exec(c) && parser.begin && parser.lastpos) {
        parser.addEvent(parser.begin, parser.lastpos, "value");
        if (!(c === '\r' || c === '\n')) {
            parser.addEvent(pos, pos, "attr_space");
        }
        parser.begin = null;
        return State.SCANNING;
    }
    else {
        return State.FAIL;
    }
};
handlers[State.SCANNING_ESCAPED] = function (parser, pos) {
    return State.SCANNING_QUOTED_VALUE;
};
handlers[State.SCANNING_ESCAPED_IN_CONTINUATION] = function (parser, pos) {
    return State.SCANNING_QUOTED_VALUE_CONTINUATION;
};
handlers[State.SCANNING_QUOTED_VALUE] = function (parser, pos) {
    const c = parser.subject.charAt(pos);
    if (c === '"' && parser.begin && parser.lastpos) {
        parser.addEvent(parser.begin + 1, parser.lastpos, "value");
        parser.addEvent(pos, pos, "attr_quote_marker");
        parser.begin = null;
        return State.SCANNING;
    }
    else if (c === "\n" && parser.begin && parser.lastpos) {
        parser.addEvent(parser.begin + 1, pos, "value");
        parser.begin = null;
        return State.SCANNING_QUOTED_VALUE_CONTINUATION;
    }
    else if (c === "\\") {
        return State.SCANNING_ESCAPED;
    }
    else {
        return State.SCANNING_QUOTED_VALUE;
    }
};
handlers[State.SCANNING_QUOTED_VALUE_CONTINUATION] = function (parser, pos) {
    const c = parser.subject.charAt(pos);
    if (parser.begin === null) {
        parser.begin = pos;
    }
    if (c === '"' && parser.begin && parser.lastpos) {
        parser.addEvent(pos, pos, "attr_quote_marker");
        parser.addEvent(parser.begin, parser.lastpos, "value");
        parser.begin = null;
        return State.SCANNING;
    }
    else if (c === "\n" && parser.begin && parser.lastpos) {
        parser.addEvent(parser.begin, pos, "value");
        parser.begin = null;
        return State.SCANNING_QUOTED_VALUE_CONTINUATION;
    }
    else if (c === "\\") {
        return State.SCANNING_ESCAPED_IN_CONTINUATION;
    }
    else {
        return State.SCANNING_QUOTED_VALUE_CONTINUATION;
    }
};
class AttributeParser {
    constructor(subject) {
        this.subject = subject;
        this.state = State.START;
        this.begin = null;
        this.lastpos = null;
        this.matches = [];
    }
    addEvent(startpos, endpos, annot) {
        this.matches.push({ startpos: startpos, endpos: endpos, annot: annot });
    }
    /* Feed parser a slice of text from the subject, between
     * startpos and endpos inclusive.  Return object with
     * status and position,
     * where status is either "done" (position should point to
     * final '}'), "fail" (position should point to first character
     * that could not be parsed), or "continue" (position should
     * point to last character parsed). */
    feed(startpos, endpos) {
        let pos = startpos;
        while (pos <= endpos) {
            this.state = handlers[this.state](this, pos);
            if (this.state === State.DONE) {
                return { status: "done", position: pos };
            }
            else if (this.state === State.FAIL) {
                this.lastpos = pos;
                return { status: "fail", position: pos };
            }
            else {
                this.lastpos = pos;
                pos = pos + 1;
            }
        }
        return { status: "continue", position: endpos };
    }
}
exports.AttributeParser = AttributeParser;
